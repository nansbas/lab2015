%% Extract V4 neural features at given frames.
%   - img: RGB or gray-scale image which will go through multiple scale of
%   simple cells and complex cells.
%   - frames: feature frames generated by kadir2001 detector, in the format of frame
%   per column, [x;y;scale;...].
%   - f: output features. Unlike configurations in other part of this
%   program (especially ethzshap), the features are per column. This is for
%   compatibility with VL_FEAT library.
function f = NeuralFeature(img, frames)
  frames(1:2,:) = round(frames(1:2,:));
  scales = frames(3,:);
  temp = round((scales - min(scales)) / (max(scales) - min(scales)) * 3);
  scales = round(temp / 3 * (max(scales) - min(scales))) + min(scales);
  scales(scales < 8) = 8;
  [nscales,~,scaleIdx] = unique(scales);
  simpleRFsize = round(nscales/3);
  complexRFsize = round(nscales);
  oriRange = 0:22.5:170;
  f = zeros(length(oriRange)*16, size(frames,2));
  cout = cell(1,length(nscales));
  for i = 1:length(nscales)
    rf = MakeSimpleRF(simpleRFsize(i), oriRange, [1,length(oriRange)]);
    out = SimpleCell(img, rf);
    cout1 = zeros(size(out));
    for j = 1:size(out,3)
      cout1(:,:,j) = imfilter(out(:,:,j), fspecial('gaussian', complexRFsize(i), complexRFsize(i)), 'replicate');
    end
    cout{i} = cout1;
  end
  [x,y] = meshgrid(-1.5:1.5);
  for i = 1:length(scaleIdx)
    px = round(x(:) * complexRFsize(scaleIdx(i)) + frames(1,i));
    py = round(y(:) * complexRFsize(scaleIdx(i)) + frames(2,i));
    if sum(px < 1) > 0 || sum(px > size(img,2)) > 0, continue; end
    if sum(py < 1) > 0 || sum(py > size(img,1)) > 0, continue; end
    for j = 1:16
      f((1:length(oriRange))+(j-1)*length(oriRange),i) = cout{scaleIdx(i)}(py(j),px(j),:);
    end
  end
end
